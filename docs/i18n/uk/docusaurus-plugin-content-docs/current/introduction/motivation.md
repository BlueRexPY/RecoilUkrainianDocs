---
title: Мотивація
---

З міркувань сумісності та простоти - найкраще використовувати вбудовані можливості управління станом React, а не зовнішній глобальний стан. Але React має певні обмеження:

- Стан компонента можна розділити, лише передавши його спільному предку, але це може включати величезне дерево, яке потім потрібно повторно рендерити.
- Контекст може зберігати лише одне значення, а не невизначений набір значень, кожне з яких має своїх споживачів.
- Обидва вони ускладнюють кодове відокремлення верхівки дерева (де має бути стан) від гілок дерева (де використовується стан).

Ми хочемо покращити це, зберігаючи як API, так і семантику та поведінку максимально реактивними.

Recoil визначає орієнтований графік, ортогональний, але також внутрішній і прикріплений до вашого React дерева. Зміни стану надходять від коренів цього графіка (які ми називаємо "атомами") через чисті функції (які ми називаємо "селектори") і в компоненти. При такому підході:

- Ми отримуємо API без скелетного коду, де загальний стан має той самий простий інтерфейс get / set, що і локальний стан React (але при необхідності може бути інкапсульований за допомогою редукторів тощо).
- У нас є можливість сумісності з Concurrent Mode та іншими новими функціями React, як тільки вони стануть доступними.
- Визначення стану є інкрементальним та розподіленим, що робить можливим фрагментацію коду.
- Стан можна замінити похідними даними без зміни компонентів, які його використовують.
- Похідні дані можуть змінюватися з синхронних на асинхронні без зміни компонентів, які їх використовують.
- Ми можемо розглядати навігацію як першокласну концепцію, навіть кодуючи переходи станів у посиланнях.
- Легко зберегти весь стан програми назад сумісним способом, щоб постійні стани могли витримати зміни, внесені в додаток.
