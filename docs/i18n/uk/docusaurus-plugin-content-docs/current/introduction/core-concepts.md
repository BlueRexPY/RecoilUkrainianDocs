---
title: Основне поняття
---

## Огляд

Recoil дозволяє створити графік потоку даних, який тече від _атомів_ (спільний стан) через _селектори_ (чисті функції) і вниз по ваших компонентах React. Атоми - це одиниці стану, на які компоненти можуть підписуватися. Селектори перетворюють цей стан синхронно або асинхронно.

## Атоми

Атоми - це одиниці стану. Вони можуть бути оновлені, і на них можна підписатися: коли атом оновлюється, кожен підписаний компонент повторно відображається з новим значенням. Вони також можуть бути створені під час виконання. Атоми можуть використовуватися замість локального стану компонента React. Якщо один і той же атом використовується з декількох компонентів, всі ці компоненти поділяють свій стан.

Атоми створюються за допомогою функції `atom`:

```javascript
const fontSizeState = atom({
  key: 'fontSizeState',
  default: 14,
});
```

Атомам потрібен унікальний ключ, який використовується для налагодження, збереження та для деяких розширених API, які дозволяють бачити карту всіх атомів. Для двох атомів помилково мати один і той же ключ, тому переконайтеся, що вони унікальні у всьому додатку. Як і локальні стани компонента React, вони також мають значення за замовчуванням.

Для читання та запису атома з компонента ми використовуємо _Hook_ з назвою 'useRecoilState'. Це схоже на React hook `useState', але тепер стан можна розділити між компонентами:
 
```jsx
function FontButton() {
  const [fontSize, setFontSize] = useRecoilState(fontSizeState);
  return (
    <button onClick={() => setFontSize((size) => size + 1)} style={{fontSize}}>
      Натисніть, щоб збільшити розмір шрифту
    </button>
  );
}
```

Натискання кнопки - збільшить розмір шрифту кнопки на одиницю. Але тепер інший компонент також може використовувати той самий розмір шрифту:

```jsx
function Text() {
  const [fontSize, setFontSize] = useRecoilState(fontSizeState);
  return <p style={{fontSize}}>цей текст також буде збільшено</p>;
}
```

## Селектори

**Селектор** - це чиста функція, яка приймає атоми або інші селектори як вхідні дані. Коли ці атоми або вищі селектори оновлюються, селектор буде переоцінений. Компоненти можуть підписуватися на селектори так само, як атоми, і потім будуть повторно відображатися при зміні селекторів.

Селектори використовуються для обчислення похідних даних на основі стану. Це дозволяє уникнути надмірного стану, оскільки мінімальний набір станів зберігається в атомах, тоді як все інше ефективно обчислюється як функція цього мінімального стану. Оскільки селектори відстежують, які компоненти їм потрібні та від якого стану вони залежать, вони роблять цей функціональний підхід дуже ефективним.

З точки зору компонентів, селектори та атоми мають однаковий інтерфейс і тому можуть бути замінені один одним.

Селектори визначаються за допомогою функції  `selector`:

```javascript
const fontSizeLabelState = selector({
  key: 'fontSizeLabelState',
  get: ({get}) => {
    const fontSize = get(fontSizeState);
    const unit = 'px';

    return `${fontSize}${unit}`;
  },
});
```

Властивість `get` - це функція, яку потрібно обчислити. Вона може отримати доступ до значень атомів та інших селекторів, використовуючи переданий їй аргумент `get`. Щоразу, коли він отримує доступ до іншого атома або селектора, створюється залежність, так що оновлення іншого атома або селектора призводить до його повторного обчислення.

У цьому прикладі стану `fontSizeLabel` селектор має одну залежність: атом `fontSizeState`. Концептуально селектор `fontSizeLabelState` поводиться як чиста функція, яка приймає `fontSizeState` як вхідні дані та повертає форматовану мітку розміру шрифту як вихідні дані.

Селектори можна прочитати за допомогою функції `useRecoilValue()`, яка приймає атом або селектор як аргумент і повертає відповідне значення. Ми не використовуємо `useRecoilState()`, оскільки селектор `fontSizeLabelState` недоступний для запису (див. [selector API](/docs/api-reference/core/selector) для отримання додаткової інформації про селектори, доступні для запису):

```jsx
function FontButton() {
  const [fontSize, setFontSize] = useRecoilState(fontSizeState);
  const fontSizeLabel = useRecoilValue(fontSizeLabelState);

  return (
    <>
      <div>Поточний розмір шрифту: ${fontSizeLabel}</div>

      <button onClick={() => setFontSize(fontSize + 1)} style={{fontSize}}>
        Натисніть, щоб збільшити
      </button>
    </>
  );
}
```

Натискання кнопки тепер робить дві речі: збільшує розмір шрифту кнопки, а також оновлює мітку розміру шрифту, щоб відобразити поточний розмір шрифту.
