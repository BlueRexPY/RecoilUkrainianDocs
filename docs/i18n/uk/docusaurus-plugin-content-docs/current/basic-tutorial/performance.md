---
title: 'Бонус: Продуктивність'
---

Наша існуюча реалізація цілком працездатна, але є деякі важливі показники продуктивності, які необхідно враховувати, оскільки наш додаток перетворюється з невеликого іграшкового проекту на корпоративну програму на мільйон рядків.

Давайте подумаємо про те, що призведе до повторного відтворення кожного з наших компонентів:

### `<TodoList />`
re render
Цей компонент підписаний на `filteredTodoListState`, який є селектором, який залежить від `todoListState` і `todoListFilterState`. Це означає, що `TodoList` буде повторно відтворено, коли наступний стан зміниться:

- `todoListState`
- `todoListFilterState`

### `<TodoItem />`

Цей компонент підписаний на `todoListState`, тому він буде повторно відображати щоразу, коли `todoListState` змінюється, і щоразу, коли його батьківський компонент, `TodoList`, повторно відтворюється.

### `<TodoItemCreator />`

Цей компонент не підписаний на стан Recoil (`useSetRecoilState()` не створює підписку), тому він буде повторно відтворюватися лише тоді, коли його батьківський компонент, `TodoList`, повторно відтворюється.

### `<TodoListFilters />`

Цей компонент підписаний на `todoListFilterState`, тому він буде повторно відтворюватися, коли змінюється цей стан або коли його батьківський компонент, `TodoList`, повторно відтворюється.

### `<TodoListStats />`

Цей компонент підписаний на `filteredTodoListState`, тому він буде повторно відображати щоразу, коли цей стан змінюється або коли його батьківський компонент, `TodoList`, повторно відтворюється.

## Простір для вдосконалення

Існуюча реалізація має кілька недоліків, головним чином той факт, що ми повторно відтворюємо все дерево щоразу, коли вносимо будь-які зміни до `todoListState` через те, що `<TodoList />` є батьківським для всіх наших компонентів, тому коли він повторно відтворюється, всі його дочірні елементи повторіть за ним.

В ідеалі компоненти мали б повторно відтворювати лише тоді, коли це абсолютно необхідно (коли дані, які вони відображають на екрані, змінилися).

## Оптимізація #1: `React.memo()`

Щоб пом’якшити проблему непотрібного повторного відтворення дочірніх компонентів, ми можемо використати [`React.memo()`](https://reactjs.org/docs/react-api.html#reactmemo), який запам’ятовує компонент на основі **props**, переданих цьому компоненту:

```js
const TodoItem = React.memo(({item}) => ...);

const TodoItemCreator = React.memo(() => ...);

const TodoListFilters = React.memo(() => ...);

const TodoListStats = React.memo(() => ...);
```

Це допомагає з повторним відтворенням `<TodoItemCreator />` і `<TodoListFilters />`, оскільки вони більше не відображаються повторно у відповідь на повторне відтворення їх батьківського компонента, `<TodoList />`, але ми все ще маємо проблема повторного рендерингу `<TodoItem />` і `<TodoListStats />`, коли текст окремих елементів завдань змінюється, оскільки зміни тексту призведуть до нового `todoListFilterState`, який і `<TodoItem />`, і `< На TodoListStats />` підписані.

## Оптимізація #2: `atomFamily()`

### Переосмислення форми стану

Розглядати список завдань як масив об’єктів проблематично, оскільки він створює тісний зв’язок між кожним окремим пунктом справ і списком усіх елементів завдань.

Щоб вирішити цю проблему, нам потрібно переосмислити нашу форму стану, подумавши про **нормалізований стан**. У контексті нашої програми зі списком завдань це означає збереження **списку** ідентифікаторів елементів окремо від **даних** для кожного окремого елемента.

> Для більш детального обговорення того, як думати про нормалізований стан, перегляньте [цю сторінку з документації Redux](https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape).

Зрештою, це означає, що ми розділимо наш `todoListState` на два:

- Масив ідентифікаторів елементів завдань
- Зіставлення ідентифікатора елемента з даними елемента

Масив ідентифікаторів елементів завдань можна реалізувати за допомогою атома таким чином:

```javascript
const todoListItemIdsState = atom({
  key: 'todoListItemIdsState',
  default: [],
});
```

Для реалізації зіставлення ідентифікатора елемента з даними елемента, Recoil надає допоміжний метод, який дозволяє нам динамічно створювати зіставлення з ідентифікатора на атом. Це утиліта [`atomFamily()`](/docs/api-reference/utils/atomFamily).

### `atomFamily()`

Ми використовуємо функцію [`atomFamily()`](docs/api-reference/utils/atomFamily)
