---
title: Клас Snapshot
sidebar_label: Snapshot
---

Об’єкт `Snapshot` представляє незмінний знімок стану Recoil [атоми](/docs/api-reference/core/atom). Він призначений для стандартизації API для спостереження, перевірки та керування глобальним станом віддачі. Це здебільшого корисно для інструментів розробника, глобальної синхронізації стану, навігації по історії тощо.

```jsx
class Snapshot {
  retain(): () => void;
  isRetained(): boolean;

  // Засоби доступу для перевірки стану знімка
  getLoadable: <T>(RecoilValue<T>) => Loadable<T>;
  getPromise: <T>(RecoilValue<T>) => Promise<T>;

  // API для перетворення стану в новий незмінний знімок
  map: (MutableSnapshot => void) => Snapshot;
  asyncMap: (MutableSnapshot => Promise<void>) => Promise<Snapshot>;

  // Отримайте StoreID, подібний до useRecoilStoreID()
  getStoreID: () => StoreID;

  // API інструментів розробника
  getID: () => SnapshotID;
  getNodes_UNSTABLE: ({
    isModified?: boolean,
  } | void) => Iterable<RecoilValue<mixed>>;
  getInfo_UNSTABLE: <T>(RecoilValue<T>) => {...};
}

function snapshot_UNSTABLE(initializeState?: (MutableSnapshot => void)): Snapshot
```

## Отримання знімків

### Хуки

Recoil надає наступні засоби для отримання знімків на основі поточного стану:

- [`useRecoilCallback()`](/docs/api-reference/core/useRecoilCallback) - Асинхронний доступ до моментального знімка.
- [`useRecoilSnapshot()`](/docs/api-reference/core/useRecoilSnapshot) - Синхронний доступ до миттєвого знімка.
   - Використання цього хука підпише ваш компонент на повторну візуалізацію *всіх* змін стану віддачі.
- [`useRecoilTransactionObserver_UNSTABLE()`](/docs/api-reference/core/useRecoilTransactionObserver) - підписка на миттєві знімки для всіх змін стану.

### Створення нового знімка

Ви також можете створити новий знімок за допомогою фабрики `snapshot_UNSTABLE()`. Це можна використовувати для [тестування](/docs/guides/testing) або оцінювання селекторів поза контекстом React. Усі атоми на знімку запускатимуться у стані за замовчуванням, однак ефекти атомів усе одно працюватимуть і можуть ініціалізувати атоми до динамічних значень. `snapshot_UNSTABLE()` також приймає додатковий зколбек для ініціалізації стану, хоча ініціалізація ефекту атома має пріоритет. Також зауважте, що кеші селекторів є спільними для коренів і знімків Recoil, хоча їх можна очистити за допомогою [зворотних викликів](/docs/api-reference/core/selector#returning-objects-with-callbacks).

## Читання миттєвих знімків

Знімки доступні лише для читання щодо стану атома. Їх можна використовувати для читання стану атома та оцінки похідного стану селекторів. `getLoadable()` надає [`Loadable`](/docs/api-reference/core/Loadable) зі станом атома або селектора в цьому знімку. Метод `getPromise()` можна використовувати для очікування оціненого значення асинхронних селекторів, щоб ви могли побачити, яким буде значення на основі статичного стану атома.

### Приклад

```jsx
function MyComponent() {
  const logState = useRecoilCallback(({snapshot}) => () => {
    console.log("State: ", snapshot.getLoadable(myAtom).contents);

    const newSnapshot = snapshot.map(({set}) => set(myAtom, 42));
  });
}
```

## Перетворення миттєвих знімків

Бувають випадки, коли ви можете змінити знімок. Хоча миттєві знімки є незмінними, вони мають методи, щоб відобразити себе за допомогою набору перетворень у новий незмінний знімок. Метод map приймє колбек, який передається `MutableSnapshot`, який змінюється протягом зворотного виклику і в кінцевому підсумку стане новим знімком, повернутим операцією відображення.

```jsx
class MutableSnapshot {
  set: <T>(RecoilState<T>, T | DefaultValue | (T => T | DefaultValue)) => void;
  reset: <T>(RecoilState<T>) => void;
}
```

Зауважте, що `set()` і `reset()` мають той самий підпис, що й зворотні виклики, надані властивості `set` записуваного селектора, але вони впливають лише на новий знімок, а не на поточний стан.

## Перехід до моментального знімка

Наступний хук можна використати для оновлення поточного стану Recoil відповідно до наданого `Snapshot`:
- [`useGotoRecoilSnapshot()`](/docs/api-reference/core/useGotoRecoilSnapshot) - Оновлення поточного стану відповідно до миттєвого знімка

## Асинхронне використання миттєвих знімків

Знімки зберігаються лише протягом зворотного виклику, який їх отримав. Щоб використовувати їх після цього, їх слід явно зберегти за допомогою `retain()`.

```jsx
test('My Test', async () => {
  const testSnapshot = snapshot_UNSTABLE();
  const releaseSnapshot = initialSnapshot.retain();

  try {
    await something;
    ... use testSnapshot ...
  } finally {
    releaseSnapshot();
  }
});
```

```jsx
function MyComponent() {
  const myCallback = useRecoilCallback(({snapshot}) => () => {
    const release = snapshot.retain();
    setTimeout(() => {
      ... use snapshot ...
      release();
    }, 1000);
  });

  ...
}
```

Зауважте, що асинхронні селектори мають активно використовуватися деякими `<RecoilRoot>` або `Snapshot`, щоб переконатися, що вони не скасовуються. Якщо ви отримуєте доступ до асинхронного селектора лише за допомогою знімків, їх потрібно зберегти, щоб гарантувати, що ви можете спостерігати за дозволеним значенням.

## Інструменти розробника

Знімки надають деякі методи, корисні для [створення інструментів розробника](/docs/guides/dev-tools) або можливостей налагодження за допомогою Recoil. Цей API все ще розвивається, тому його позначено як `_UNSTABLE`, оскільки ми працюємо над початковими інструментами розробника.

### Ідентифікатори знімків

Кожен зафіксований стан або змінений знімок має унікальний непрозорий ідентифікатор версії, який можна отримати за допомогою `getID()`. Це можна використати, щоб визначити, коли ми повернулися до попереднього знімка за допомогою [`useGotoRecoilSnapshot()`](/docs/api-reference/core/useGotoRecoilSnapshot).

### Перерахування атомів і селекторів

Метод `getNodes_UNSTABLE()` можна використовувати для повторення всіх атомів і селекторів, які використовувалися для цього знімка. Атоми, селектори та родини можна створювати в будь-який час. Однак вони відображатимуться на знімку, лише якщо вони фактично використовуються. Атоми та селектори можуть бути видалені з наступних знімків стану, якщо вони більше не використовуються.

Можна вказати необов’язковий прапорець isModified, щоб повертати лише атоми, які були змінені після останньої транзакції.

### Інформація про налагодження

Метод `getInfo_UNSTABLE()` надає додаткову інформацію для налагодження атомів і селекторів. Надана інформація про налагодження розвивається, але може включати:

* `loadable` - Завантажуваний з поточним станом. На відміну від таких методів, як `getLoadable()`, цей метод взагалі не змінюватиме знімок. Він надає поточний стан і не буде ініціалізувати нові атоми/селектори, виконувати будь-які нові оцінки селекторів або оновлювати будь-які залежності чи підписки.
* `isSet` - True, якщо це атом із явним значенням, що зберігається у стані знімка. False, якщо це селектор або використовується стандартний стан атома.
* `isModified` - True, якщо це атом, який було змінено після останньої транзакції.
* `type` – або `атом`, або `селектор`
* `deps` – ітератор над атомами або селекторами, від яких залежить цей вузол.
* `subscribers` - інформація про те, що підписується на цей вузол для цього знімка. Деталі в розробці.

Це схоже на хук [`useGetRecoilValueInfo_UNSTABLE()`](/docs/api-reference/core/useGetRecoilValueInfo), але надає інформацію на основі стану в `Знімку` замість поточного стану. Він не може надати інформацію, не пов’язану зі знімком стану Recoil, таку як підписка на компоненти React.

## Ініціалізація стану

Компонент [`<RecoilRoot>`](/docs/api-reference/core/RecoilRoot) і фабрика `snapshot_UNSTABLE()` використовують необов’язкову властивість `initializeState` для ініціалізації стану через `MutableSnapshot`. Це може бути корисним для завантаження постійного стану, коли ви знаєте всі атоми наперед і сумісно з відтворенням на стороні сервера, де стан має бути встановлено синхронно з початковим відтворенням. Для поатомної ініціалізації/постійності та простоти роботи з динамічними атомами розгляньте [атомні ефекти](/docs/guides/atom-effects).

```jsx
function MyApp() {
  function initializeState({set}) {
    set(myAtom, 'foo');
  }

  return (
    <RecoilRoot initializeState={initializeState}>
      ...
    </RecoilRoot>
  );
}
```
